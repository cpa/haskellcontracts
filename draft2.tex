\documentclass{article}

\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{fullpage}

\begin{document}

\newcommand{\etrans}[1]{\mathcal{E} \llbracket #1 \rrbracket}
\newcommand{\dtrans}[1]{\mathcal{D} \llbracket #1 \rrbracket}
\newcommand{\ttrans}[1]{\mathcal{T} \llbracket #1 \rrbracket}
\newcommand{\strans}[1]{\mathcal{S} \llbracket #1 \rrbracket}
\newcommand{\cf}[1]{\mbox{CF}(#1)}
\newcommand{\trans}[1]{\llbracket #1 \rrbracket}

\newcommand{\unr}{\texttt{UNR}}
\newcommand{\bad}{\texttt{BAD}}
\newcommand{\any}{\texttt{Any}}
\newcommand{\ok}{\texttt{Ok}}

\thispagestyle{empty}
\section{Grammars}

In the following, $D$ is a data constructor, $f$ a function symbol and we consider them as strings. $n$ represents an integer.

\subsection{$\lambda$-lifted haskell subset}
\begin{center}
\begin{array}{rclr}
  u,e &:=& x \mid f \mid e~e \mid D(e,\dots,e) \mid \bad \mid n & (Expression)\\
  p &:=& \Delta,p \mid T,p \mid \epsilon & (Program)\\
  %\Delta &:=& d \mid transp (d,c) \mid opaque (d,c) & (Defintion~and~contract)\\
  d &:=& f~x_1 \dots x_n = e \mid f~x_1 \dots x_n = \mbox{ case } e \mbox{ of } [(pat_i,e_i)] & (Definition)\\
  T &:=& \mbox{data } x~\tau_1 \dots \tau_n = D_1 ; D_2 ; \dots ; D_n & (Data~type~definition)\\ %TODO make type clearer
  pat &:=& D(x_1,\dots,x_n) & (Pattern)\\
\end{array}
\end{center}

\subsection{FOL}
\begin{center}
\begin{array}{rclr}
  t &:=& x \mid \mbox{app}(t_1,t_2) \mid D(t,\dots,t) \mid f \mid n \mid \bad \mid \unr \mid \mbox{CF}(t) & (Term)\\
  \phi &:=& \forall x.\phi \mid \phi \to \phi \mid \lnot \phi \mid \phi \lor \phi \mid \phi \land \phi \mid true \mid t=t \mid \mbox{CF}(t)& (Formula)\\
\end{array}
\end{center}
CF$(t)$ holds iff $t$ satisfies $\ok$.

\subsection{Contracts}
\begin{center}
\begin{array}{rclr}
  c &:=& x:c_1 \to c_2\\
  &\mid& (c_1,c_2) \\
  &\mid& \{ x \mid e \}\\
  &\mid& \any \\
\end{array}
\end{center}

Semantics of contract satisfaction:
\begin{center}
\begin{array}{rcl}
  e \in \{x \mid p \} &\iff& e \mbox{ diverges or } (e \mbox{ is crash-free and } p[e/x] \not \to^\star \{\bad,\unr\})\\
  e \in x:t_1 \to t_2 &\iff& \forall e_1 \in t_1, (e~e_1) \in t_2[e_1/x]\\
  e \in (t_1,t_2) &\iff& e \mbox{ diverges or } (e \to^\star (e_1,e_2) \mbox{ and } e_1 \in t_1, e_2 \in t_2)\\
  e \in \any &\iff& True  
\end{array}
\end{center}


\section{Translation}
We define several translations: $\etrans{},\dtrans{},\ttrans{},\strans{}$.
\begin{center}
\begin{array}{rclr}
  \etrans{} &::& Expression \to Term\\
  \dtrans{} &::& Definition \to FOF\\
  \ttrans{} &::& Data~type  \to FOF\\
  \strans{} &::& Expression \to Contract \to FOF\\
%  \trans {} &::& Definition \to Contract \to FOF\\
\end{array}
\end{center}

\subsection{$\etrans{}$}
$\etrans{e}$ is a term. 

\begin{eqnarray}
\etrans{x} &=& x\\
\etrans{f} &=& f\\
\etrans{e_1~e_2} &=& app(e_1,e_2)\\
\etrans{D(e_1,\dots,e_n)} &=& D(\etrans{e_1},\dots,\etrans{e_n}\\
\etrans{\bad} &=& \bad\\
\etrans{n} &=& n\\

\subsection{$\dtrans{}$}
$\dtrans{d}$ is a first-order formula.

\begin{eqnarray}
\dtrans{f~x_1 \dots x_n = e} &=& \forall x_1 \dots x_n.\etrans{f~x_1 \dots x_n} = \etrans{e}\\
\dtrans{f~x_1 \dots x_n = \mbox{case } e \mbox{ of } [D_i~\overline{z} \mapsto e_i]} &=& \forall x_1 \dots x_n~(\bigwedge_i (\forall \overline{z}~\etrans{e} = \etrans{D_i~\overline{z}} \to \etrans{f~x_1 \dots x_n} = \etrans{e_i})\\
&& \land \etrans{e} = \bad \to \etrans{f~x_1 \dots x_n} = \bad)\\ 
&& \land (\etrans{f~x_1 \dots x_n} = \unr \bigvee_i (\texttt{HD}(e) = D_i) \lor e = \bad)
\end{eqnarray}

Can't we just put a XOR instead of OR in the last line?

\subsection{$\strans{}$}
$\strans{e \in c}$ is a first-order formula.
\begin{eqnarray}
\strans{e \in \any} &=& true\\
\strans{e \in \{x \mid u \}} &=& e = \unr \lor (\mbox{CF}(\etrans{e}) \land \etrans{u[e/x]} \neq \bad \land \etrans{u[e/x]} \neq False)\\
\strans{e \in x:c_1 \to c_2}  &=& \forall x_1. \strans{x_1 \in c_1} \to \strans{e~x_1 \in c_2[x_1/x]}
\end{eqnarray}
$False$ is a data constructor here.

Remark: we follow the semantics of the POPL paper but it's a bit restrictive.
e.g. in equation 13 we could use the alternate semantics (namely B1 in the POPL paper) : 
$$\strans{e \in \{x \mid u \}} = e = \unr \lor (\etrans{u[e/x]} \neq \bad \land \etrans{u[e/x]} \neq False)$$

\thispagestyle{empty}

\section{Datatypes}
$\ttrans{T}$ is a set of first-order formulae.
$\ttrans{\mbox{data } T = D_1 ; \dots ; D_n} = S_1 \cup S_2 \cup S_3$.

First, for each $D_i$ we introduce selectors $sel_{k,D_i}$, which are basically projections of $D_i(x_1,\dots,x_n)$ on its $k$-th composant, so that we can express that constructors are injective :
$$S_1 := \{ \forall x_1,\dots,x_n . \bigwedge_{1 \leq i \leq n} sel_{i,D_i}(D_i(x_1,\dots,x_n)) = x_i \mid 1 \leq i \ n \}$$

For each pair of different constructors $D_i,D_j$, we state that they can never map to the same value: 
$$S_2 := \{ \forall x_1,\dots,x_n~\forall y_1,\dots,y_k . D_i(x_1,\dots,x_n) \neq D_j(y_1,\dots,y_k) \mid 1 \leq i < j \leq n \}$$

Finally, we have to give crash-freeness conditions for each $D_i$:
$$S_3 := \{ \forall x_1,\dots,x_n . (\cf{x_1} \land \dots \land \cf{x_n} \leftrightarrow \cf{D_i(x_1,\dots,x_n)}) \mid 1 \leq i \leq n \}$$

\thispagestyle{empty}
\end{document}

