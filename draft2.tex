\documentclass{article}

\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{fullpage}

\begin{document}

\newcommand{\etrans}[1]{\mathcal{E} \llbracket #1 \rrbracket}
\newcommand{\dtrans}[1]{\mathcal{D} \llbracket #1 \rrbracket}
\newcommand{\ttrans}[1]{\mathcal{T} \llbracket #1 \rrbracket}
\newcommand{\strans}[1]{\mathcal{S} \llbracket #1 \rrbracket}
\newcommand{\cf}[1]{\mbox{CF}(#1)}
\newcommand{\trans}[1]{\llbracket #1 \rrbracket}

\newcommand{\unr}{\texttt{UNR}}
\newcommand{\bad}{\texttt{BAD}}
\newcommand{\any}{\texttt{Any}}
\newcommand{\ok}{\texttt{Ok}}

\section{Grammars}

In the following, $D$ is a data constructor, $f$ a function symbol and we consider them as strings. $n$ represents an integer.

\subsection{$\lambda$-lifted haskell subset}
\begin{center}
\begin{array}{rclr}
  u,e &:=& x \mid f \mid e~e \mid D(e,\dots,e) \mid \bad \mid n & (Expression)\\
  p &:=& \Delta,p \mid T,p \mid f \in c,p \mid \epsilon & (Program)\\
  \Delta &:=& d \mid opaque(d) & (Defintion~and~scope)\\
  d &:=& f~x_1 \dots x_n = e \mid f~x_1 \dots x_n = \mbox{ case } e \mbox{ of } [(pat_i,e_i)] & (Definition)\\
  T &:=& \mbox{data } x = D_1 ; D_2 ; \dots ; D_n & (Data~type~definition)\\ %TODO make type clearer
  pat &:=& D(x_1,\dots,x_n) & (Pattern)\\
\end{array}
\end{center}

For the moment we consider data constructors to be saturated, ie fully applied (hence the special application syntax).


\subsection{FOL}
\begin{center}
\begin{array}{rclr}
  t &:=& x \mid \mbox{app}(t_1,t_2) \mid D(t,\dots,t) \mid f \mid n \mid \bad \mid \unr \mid \mbox{CF}(t) & (Term)\\
  \phi &:=& \forall x.\phi \mid \phi \to \phi \mid \lnot \phi \mid \phi \lor \phi \mid \phi \land \phi \mid true \mid t=t \mid \mbox{CF}(t)& (Formula)\\
\end{array}
\end{center}
CF$(t)$ holds iff $t$ satisfies $\ok$.

\subsection{Contracts}
\begin{center}
\begin{array}{rclr}
  c &:=& x:c_1 \to c_2\\
  &\mid& (c_1,c_2) \\
  &\mid& \{ x \mid e \}\\
  &\mid& \any \\
\end{array}
\end{center}

Semantics of contract satisfaction:
\begin{center}
\begin{array}{rcl}
  e \in \{x \mid p \} &\iff& e \mbox{ diverges or } (e \mbox{ is crash-free and } p[e/x] \not \to^\star \{\bad,\unr\})\\
  e \in x:t_1 \to t_2 &\iff& \forall e_1 \in t_1, (e~e_1) \in t_2[e_1/x]\\
  e \in (t_1,t_2) &\iff& e \mbox{ diverges or } (e \to^\star (e_1,e_2) \mbox{ and } e_1 \in t_1, e_2 \in t_2)\\
  e \in \any &\iff& True  
\end{array}
\end{center}


\section{Translation}
We define several translations: $\etrans{},\dtrans{},\ttrans{},\strans{},\trans{}$.
\begin{center}
\begin{array}{rclr}
  \etrans{} &::& Expression \to Term\\
  \dtrans{} &::& Definition \to FOF\\
  \ttrans{} &::& Data~type  \to \{ FOF \}\\
  \strans{} &::& Expression \to Contract \to FOF\\
  \trans {} &::& Program    \to \{ FOF \}\\
\end{array}
\end{center}

\subsection{$\etrans{}$}
$\etrans{e}$ is a term, the translation is really straightforward.

\begin{eqnarray}
\etrans{x} &=& x\\
\etrans{f} &=& f\\
\etrans{e_1~e_2} &=& app(e_1,e_2)\\
\etrans{D(e_1,\dots,e_n)} &=& D(\etrans{e_1},\dots,\etrans{e_n})\\
\etrans{\bad} &=& \bad\\
\etrans{n} &=& n\\


\subsection{$\ttrans{}$}
$\ttrans{T}$ is a set of first-order formulae which we break down in three parts:
$\ttrans{\mbox{data } T = D_1 ; \dots ; D_n} = S_1 \cup S_2 \cup S_3$.

First, for each $D_i$ of arity $n_i$ we introduce selectors $sel_{k,D_i}$, which are projections of $D_i(x_1,\dots,x_n_i)$ on its $k$-th composant, so that we can express that constructors are injective :
$$S_1 := \{ \forall x_1,\dots,x_{n_i} . \bigwedge_{1 \leq j \leq n} sel_{j,D_i}(D_i(x_1,\dots,x_{n_i})) = x_j \mid 1 \leq i \leq n \}$$

For each pair of different constructors $D_i,D_j$, we state that they can never map to the same value: 
$$S_2 := \{ \forall x_1,\dots,x_{n_i}~\forall y_1,\dots,y_{n_j} . D_i(x_1,\dots,x_{n_i}) \neq D_j(y_1,\dots,y_{n_j}) \mid 1 \leq i < j \leq n \}$$

Finally, we have to give crash-freeness conditions for each $D_i$:
$$S_3 := \{ \forall x_1,\dots,x_{n_i} . (\cf{x_1} \land \dots \land \cf{x_{n_i}} \leftrightarrow \cf{D_i(x_1,\dots,x_{n_i})}) \mid 1 \leq i \leq n \}$$


\subsection{$\dtrans{}$}
$\dtrans{d}$ is a first-order formula.

\begin{eqnarray}
\dtrans{f~\overline{x} = e} &=& \forall x_1 \dots x_n.\etrans{f~x_1 \dots x_n} = \etrans{e}\\
\dtrans{f~\overline{x} = \mbox{case } e \mbox{ of } [D_i(\overline{z}) \mapsto e_i]} &=& \forall x_1 \dots x_n.(\bigwedge_i (\forall \overline{z}~\etrans{e} = \etrans{D_i(\overline{z})} \to \etrans{f~\overline{x}} = \etrans{e_i})\\
&& \land \etrans{e} = \bad \to \etrans{f~x_1 \dots x_n} = \bad)\\ 
&& \land ((\bigwedge_i e \neq D_i(sel_{1,D_i}(e),\dots,sel_{n_i,D_i}(e)) \land \etrans{e} \neq \bad)\\
&& ~~\to \etrans{f~x_1 \dots x_n} = \unr)
\end{eqnarray}

An alternative to using selectors would be to write something along the line of $\exists y_1,\dots,y_{D_i}. e \neq D_i(y_1,\dots,y_{D_i})$. It is equivalent but the skolemisation process of equinox will anyway turn those existentials in selectors functions. But if we pattern match $D_i$ in two different functions, we would get two different selectors (the same selector with two different names) so it's better (for the efficiency of the proof) to define selectors for each $D_i$ once in for all and use it as much as possible afterwards.


\subsection{$\strans{}$}
$\strans{e \in c}$ is a first-order formula.
\begin{eqnarray}
\strans{e \in \any} &=& true\\
\strans{e \in \{x \mid u \}} &=& e = \unr \lor (\mbox{CF}(\etrans{e}) \land \etrans{u[e/x]} \neq \bad \land \etrans{u[e/x]} \neq False)\\
\strans{e \in x:c_1 \to c_2}  &=& \forall x_1. \strans{x_1 \in c_1} \to \strans{e~x_1 \in c_2[x_1/x]}
\end{eqnarray}
$False$ is a data constructor here.

Remark: we follow the semantics of the POPL paper but it's a bit restrictive.
e.g. in equation 13 we could use the alternate semantics (namely B1 in the POPL paper) : 
$$\strans{e \in \{x \mid u \}} = e = \unr \lor (\etrans{u[e/x]} \neq \bad \land \etrans{u[e/x]} \neq False)$$

\subsection{$\trans{}$}
$\trans{p}$ defines the translation of a program to a theory (a set of FO formulae)

\begin{eqnarray}
\trans{\epsilon} &=& \emptyset\\
\trans{d,p} &=& \dtrans{d} \cup \trans{p}\\
\trans{opaque(d),p} &=& \dtrans{d} \cup \trans{p}\\
\trans{T,p} &=& \ttrans{T} \cup \trans{p}\\
\trans{f \in c,p} &=& \strans{f \in c} \cup \trans{p}\\
\end{eqnarray}

\section{User interaction}

The user provides a program $p$ which consists of functions definition (either opaque or transparent), data types definition and claims that functions satisfies contracts.

Then, for each function definition $d_f := f~x_1 \dots x_n = e$ of a function $f$ that has to satisfy the set of contracts $C_f$, we construct the context $C = p \setminus ( d_f \cup C_f )$, which is basically the program $p$ without the definition of $f$ and the contracts it has to satisfy. 

We then want to check (with equinox) that:
 $$\trans{C} \cup \{ \dtrans{f~x_1 \dots \x_n = e[f^\star/f]}, \bigwedge_{c \in C_f} \strans{f^\star \in c} \} \models \bigwedge_{c \in C_f} \strans{f \in c}$$

Which we rewrite as:
 $$\trans{C} \cup \{ \dtrans{f~x_1 \dots \x_n = e[f^\star/f]}, \bigwedge_{c \in C_f} \strans{f^\star \in c},  \bigvee_{c \in C_f} \lnot \strans{f \in c} \} \models \bot$$

\section{Remarks}
\begin{itemize}
\item What to do with mutually recursive functions?
\item Explore the variants translations (cf variants of the popl paper)
\end{itemize}

\end{document}

