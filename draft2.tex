\documentclass{article}

\usepackage{stmaryrd}
\usepackage{fullpage}

\begin{document}

\section{Language}

\newcommand{\unr}{\texttt{UNR}}
\newcommand{\bad}{\texttt{BAD}}
\newcommand{\any}{\texttt{Any}}
\newcommand{\ok}{\texttt{Ok}}
\newcommand{\mand}{\mbox{ and }}
\newcommand{\motherwise}{\mbox{ otherwise.}}

\begin{eqnarray*}
  x,D &::=& String & (Variables, Data)\\
  e &::=& x \mid (f~\overline{e}) \mid (D~\overline{e}) & (Expressions) \\
  &&\mid \mbox{case $e$ of } [(p_1 \to e_1) \dots (p_n \to e_n)]   & \\ 
  &&\mid \bad \mid \unr & \\
  p &::=& \mbox{let } f~\overline{x} = e ::: t,p \mid \epsilon & (Programs) \\
  \Gamma &::=& (f \mapsto t),\Gamma \mid (f~\vec{x} \mapsto e), \Gamma \mid \epsilon & (Contexts) \\
  t &::=& \{x \mid e \} \mid x:t \to t \mid \any & (Contracts) \\
  \phi &::=& \top \mid \bot \mid x \mid \lnot \phi \mid \phi \land \phi \mid \forall x, \phi & (FOF) \\
\end{eqnarray*}

With the constraint that the Haskell expression in the contract must return a Bool.

$\vec{x}$ denotes a vector of variables and $\Gamma$ a context and multiset (which enables multiple contracts.)

$t \geq t' \iff \{ e | x \in t' \} \subset \{ e | x \in t \}$ ($t$ is more restrictive than $t'$)
\section{Encoding}

We define two different translations: one for expressions and one for programs. 


\subsection{Expressions}
\begin{itemize}
\item $\llbracket \Gamma \vdash \bad \in t \rrbracket = \bot$
\item $\llbracket \Gamma \vdash \unr \in t \rrbracket = \top$
\item \begin{array}{rcll}
  \llbracket \Gamma \vdash x \in t \rrbracket &=& \top & \mbox{ if } x \mapsto t' \in \Gamma \\
  && \bot & \mbox{ otherwise.} 
  \end{array}
\item \begin{array}{rcll}
  \llbracket \Gamma \vdash f~\overline{(e_1,\dots,e_n)} ::: t_1 \to \dots \to t_n \to t_c \in t_c \rrbracket &=& \bigwedge_{1 \leq i \leq n}{\llbracket \Gamma \vdash e_i \in t_i \rrbracket} \\
  \llbracket \Gamma \vdash f~\overline{(e_1,\dots,e_n)} ::: t \in t' \rrbracket &=& \bot \mbox{ ie type mismatch.}\\
  \end{array}
\item $\llbracket \Gamma \vdash D~\overline{e} \in t \rrbracket = \overline{e} \neq \bad \to \llbracket \Gamma \vdash D~\overline{e} \in \ok \rrbracket \land ...$
\item $\llbracket \Gamma \vdash \mbox{case } e \mbox{ of } [(p_1 \to e_1),\dots,(p_n \to e_n)] \in t \rrbracket = e \neq \bad \land \forall \vec{z}~p_i[\vec{z}] = e \to \llbracket \Gamma, TODO \vdash e_i \in t \rrbracket$
\end{itemize}

$$\llbracket \Gamma \vdash e \in t \rrbracket = \phi \iff (\phi = \top \iff \Gamma,e \mbox{ satisfies } t)$$

\subsection{Programs}
Assume $t = t_1 \to \dots \to t_n \to t_c$ and $\overline{x} = (x_1,\dots,x_n)$

\begin{array}{rcl}
\llbracket \Gamma \vdash \mbox{ let } f~\overline{x} = e:::t,p \rrbracket &=& \forall f^\star, \forall_{1 \leq i \leq n} x_i, \llbracket \Gamma, x_1 \mapsto t_1,\dots,x_n \mapsto t_n, f^\star \mapsto t \vdash e[f^\star/f] \in t_c \rrbracket \\
&& \land \llbracket \Gamma, f \mapsto t \vdash p \rrbracket
\end{array}


\thispagestyle{empty}
\end{document}

