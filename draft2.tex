\documentclass{article}

\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{fullpage}

\begin{document}

\newcommand{\etrans}[1]{\mathcal{E} \llbracket #1 \rrbracket}
\newcommand{\dtrans}[1]{\mathcal{D} \llbracket #1 \rrbracket}
\newcommand{\ttrans}[1]{\mathcal{T} \llbracket #1 \rrbracket}
\newcommand{\strans}[1]{\mathcal{S} \llbracket #1 \rrbracket}
\newcommand{\cf}[1]{\mbox{CF}(#1)}
\newcommand{\trans}[1]{\llbracket #1 \rrbracket}

\newcommand{\unr}{\texttt{UNR}}
\newcommand{\bad}{\texttt{BAD}}
\newcommand{\any}{\texttt{Any}}
\newcommand{\ok}{\texttt{Ok}}

\section{Grammars}

In the following, $D$ is a data constructor, $f$ a function symbol and we consider them as strings. $n$ represents an integer.

\subsection{$\lambda$-lifted haskell subset}
\begin{center}
\begin{array}{rclr}
  u,e &:=& x \mid f \mid e~e \mid D(e,\dots,e) \mid \bad \mid n & (Expression)\\
  p &:=& \Delta,p \mid T,p \mid f \in c,p \mid \epsilon & (Program)\\
  \Delta &:=& d \mid opaque(d) & (Defintion~and~scope)\\
  d &:=& f~x_1 \dots x_n = e \mid f~x_1 \dots x_n = \mbox{ case } e \mbox{ of } [(pat_i,e_i)] & (Definition)\\
  T &:=& \mbox{data } x = D_1 ; D_2 ; \dots ; D_n & (Data~type~definition)\\ %TODO make type clearer
  pat &:=& D(x_1,\dots,x_n) & (Pattern)\\
\end{array}
\end{center}

In the calculus, every definition is toplevel ($\lambda$-lifted) and there isn't any nested case.

For the moment we consider data constructors to be saturated, ie fully applied (hence the special application syntax).
That makes defining $\dtrans{}$ less painful, because we avoid a quadratic number (in the arity of the data contrustors) of axioms. cf $S_4$ below, for example.

\subsection{FOL}
\begin{center}
\begin{array}{rclr}
  t &:=& x \mid \mbox{app}(t_1,t_2) \mid D(t,\dots,t) \mid f \mid n \mid \bad \mid \unr \mid \mbox{CF}(t) & (Term)\\
  \phi &:=& \forall x.\phi \mid \phi \to \phi \mid \lnot \phi \mid \phi \lor \phi \mid \phi \land \phi \mid true \mid t=t \mid \mbox{CF}(t)& (Formula)\\
\end{array}
\end{center}
We always give the following equations to define crash-freeness:
$$\cf{\unr}, \lnot \cf{\bad}, \forall f,x~\cf{f} \land \cf{x} \implies \cf{app(f,x)}$$
Note that it's only the equation we \textit{always} give, but there some other equations that will arise from the translations below.
It does not follow exactly the semantics given by the popl paper, but we hope it'll be a sufficient approximation!

\subsection{Contracts}
\begin{center}
\begin{array}{rclr}
  c &:=& x:c_1 \to c_2\\
  &\mid& (c_1,c_2) \\
  &\mid& \{ x \mid e \}\\
  &\mid& \any \\
\end{array}
\end{center}

Semantics of contract satisfaction (exactly the same as in the POPL paper):
\begin{center}
\begin{array}{rcl}
  e \in \{x \mid p \} &\iff& e \mbox{ diverges or } (e \mbox{ is crash-free and } p[e/x] \not \to^\star \{\bad,\unr\})\\
  e \in x:t_1 \to t_2 &\iff& \forall e_1 \in t_1, (e~e_1) \in t_2[e_1/x]\\
  e \in (t_1,t_2) &\iff& e \mbox{ diverges or } (e \to^\star (e_1,e_2) \mbox{ and } e_1 \in t_1, e_2 \in t_2)\\
  e \in \any &\iff& True  
\end{array}
\end{center}

\section{Translation}
We define several translations: $\etrans{},\dtrans{},\ttrans{},\strans{},\trans{}$.
\begin{center}
\begin{array}{rclr}
  \etrans{} &::& Expression \to Term\\
  \dtrans{} &::& Definition \to FOF\\
  \ttrans{} &::& Data~type  \to \{ FOF \}\\
  \strans{} &::& Expression \to Contract \to FOF\\
  \trans {} &::& Program    \to \{ FOF \}\\
\end{array}
\end{center}

\subsection{$\etrans{}$}
$\etrans{e}$ is a term, the translation is really straightforward.

\begin{eqnarray}
\etrans{x} &=& x\\
\etrans{f} &=& f\\
\etrans{e_1~e_2} &=& app(e_1,e_2)\\
\etrans{D(e_1,\dots,e_n)} &=& D(\etrans{e_1},\dots,\etrans{e_n})\\
\etrans{\bad} &=& \bad\\
\etrans{n} &=& n\\
\end{eqnarray}

As usual, we use left associativity.

\subsection{$\ttrans{}$}
$\ttrans{T}$ is a set of first-order formulae which we break down in four parts:
$\ttrans{\mbox{data } T = D_1 ; \dots ; D_n} = S_1 \cup S_2 \cup S_3 \cup S_4$.

First, for each $D_i$ of arity $n_i$ we introduce selectors $sel_{k,D_i}$, which are projections of $D_i(x_1,\dots,x_n_i)$ on its $k$-th component:
$$S_1 := \{ \forall x_1,\dots,x_{n_i} . \bigwedge_{1 \leq j \leq n} sel_{j,D_i}(D_i(x_1,\dots,x_{n_i})) = x_j \mid 1 \leq i \leq n \}$$

For each pair of different constructors $D_i,D_j$, we state that they can never map to the same value: 
$$S_2 := \{ \forall x_1,\dots,x_{n_i}~\forall y_1,\dots,y_{n_j} . D_i(x_1,\dots,x_{n_i}) \neq D_j(y_1,\dots,y_{n_j}) \mid 1 \leq i < j \leq n \}$$

Then, we have to give crash-freeness conditions for each $D_i$:
$$S_3 := \{ \forall x_1,\dots,x_{n_i} . (\cf{x_1} \land \dots \land \cf{x_{n_i}} \leftrightarrow \cf{D_i(x_1,\dots,x_{n_i})}) \mid 1 \leq i \leq n \}$$
Note that we have an equivalence in the case of a data constructor whereas we only have an (direct) implication for functions. It's because a function, due to laziness, could not use all its arguments. For example, $fst (1,BAD)$ is crash-free but its arguments aren't.

Finally, we have to say that none of the $D_i$ is unreachable:
$$S_4 := \{ D_i(x_1,\dots,x_n) = \unr \to x_1 = \unr \lor \dots \lor x_n = \unr \mid 1 \leq i \leq n \}$$
NB: We first started with $S_4 := \{ D_i \neq \unr \mid 1 \leq i \leq n \}$, but we couldn't prove that the (add x y), defined with peano integers, satisfied ($x=0 \to y=0 \to add~x~y=0$). It's also bizarre to state that the function was $\unr$ but not its application.

\subsection{$\dtrans{}$}
$\dtrans{d}$ is a first-order formula.

\begin{eqnarray}
\dtrans{f~\overline{x} = e} &=& \forall x_1 \dots x_n.\etrans{f~x_1 \dots x_n} = \etrans{e}\\
\dtrans{f~\overline{x} = \mbox{case } e \mbox{ of } [D_i(\overline{z}) \mapsto e_i]} &=& \forall x_1 \dots x_n.(\bigwedge_i (\forall \overline{z}~\etrans{e} = \etrans{D_i(\overline{z})} \to \etrans{f~\overline{x}} = \etrans{e_i})\\
&& \land \etrans{e} = \bad \to \etrans{f~x_1 \dots x_n} = \bad)\\ 
&& \land ((\bigwedge_i e \neq D_i(sel_{1,D_i}(e),\dots,sel_{n_i,D_i}(e)) \land \etrans{e} \neq \bad)\\
&& ~~\to \etrans{f~x_1 \dots x_n} = \unr)
\end{eqnarray}

An alternative to using selectors would be to write something along the line of $\exists y_1,\dots,y_{D_i}. e \neq D_i(y_1,\dots,y_{D_i})$. It is equivalent but the skolemisation process of equinox will anyway turn those existentials in selectors functions. But if we pattern match $D_i$ in two different functions, we would get two different selectors (the same selector with two different names) so it's better (for the efficiency of the proof) to define selectors for each $D_i$ once in for all and use it as much as possible afterwards.

Equation (10) is not restrictive even in the case of laziness because $e$ is always evaluated. (TODO, but not always fully evaluated...)

Equation (11) and (12) state that if we have a type mismatch than the code is $\unr$. It should never occur because we're assuming that the code has already been typechecked.


\subsection{$\strans{}$}
$\strans{e \in c}$ is a first-order formula.
\begin{eqnarray}
\strans{e \in \any} &=& true\\
\strans{e \in \{x \mid u \}} &=& e = \unr \lor (\mbox{CF}(\etrans{e}) \land \etrans{u[e/x]} \neq \bad \land \etrans{u[e/x]} \neq False)\\
\strans{e \in x:c_1 \to c_2}  &=& \forall x_1. \strans{x_1 \in c_1} \to \strans{e~x_1 \in c_2[x_1/x]}
\end{eqnarray}
$False$ is a data constructor here.

Remark: we follow the semantics of the POPL paper but it's a bit restrictive.
e.g. in equation 14 we could use the alternate semantics (namely B1 in the POPL paper) : 
$$\strans{e \in \{x \mid u \}} = e = \unr \lor (\etrans{u[e/x]} \neq \bad \land \etrans{u[e/x]} \neq False)$$

\subsection{$\trans{}$}
$\trans{p}$ defines the translation of a program to a theory (a set of FO formulae)

We have to give some semantics to $\cf{}$, $\bad$ and $\unr$, which are given below.

\begin{eqnarray}
\trans{\epsilon} &=& \{ \cf{\unr}, \lnot \cf{\bad}, \forall f,x~\cf{f} \land \cf{x} \implies \cf{app(f,x)} \}\\
\trans{d,p} &=& \dtrans{d} \cup \trans{p}\\
\trans{opaque(d),p} &=& \dtrans{d} \cup \trans{p}\\
\trans{T,p} &=& \ttrans{T} \cup \trans{p}\\
\trans{f \in c,p} &=& \strans{f \in c} \cup \trans{p}\\
\end{eqnarray}

\section{User interaction}

The user provides a program $p$ which consists of functions definition (either opaque or transparent), data types definition and claims that functions satisfies contracts.

Then, for each function definition $d_f := f~x_1 \dots x_n = e$ of a function $f$ that has to satisfy the set of contracts $C_f$, we construct the context $C = p \setminus ( d_f \cup C_f )$, which is basically the program $p$ without the definition of $f$ and the contracts it has to satisfy. 

We then want to check (with equinox) that:
 $$\trans{C} \cup \{ \dtrans{f~x_1 \dots \x_n = e[f^\star/f]}, \bigwedge_{c \in C_f} \strans{f^\star \in c} \} \models \bigwedge_{c \in C_f} \strans{f \in c}$$

Which we rewrite as:
 $$\trans{C} \cup \{ \dtrans{f~x_1 \dots \x_n = e[f^\star/f]}, \bigwedge_{c \in C_f} \strans{f^\star \in c},  \bigvee_{c \in C_f} \lnot \strans{f \in c} \} \models \bot$$

\section{Example}
Consider the following program (the integer after a data constructor is its arity):
\begin{verbatim}
data List = Nil 0
          | Cons 2;;

data Bool = True 0
          | False 0;;

copy x = case x of
  | Nil -> x
  | Cons a b -> Cons a (copy b);;

copy ::: a:{x : True} -> {y:True};;
\end{verbatim}
The contract states that if we give to copy a crash-free argument $x$, copy will return a crash-free result $y$.
Note that [Just BAD] is not crash-free in our sense, so we can't say anything about it. TODO (or can we?)


\begin{verbatim}
data Nat = Zero 0
         | Succ 1;;

data Bool = True 0
          | False 0;;

add x y = case x of
        | Zero -> y
        | Succ z -> Succ (add z y);;

isZero x = case x of
         | Zero -> True
         | Succ z -> False;;

not x = case x of
      | True -> False
      | False -> True;;

add ::: a:{x : True} -> {y:True} -> {z: True};;             -- C1
add ::: a:{x : isZero x} -> {y:isZero y} -> {z: True};;     -- C2
add ::: a:{x : isZero x} -> {y:isZero y} -> {z: isZero z};; -- C3
\end{verbatim}

As of today, we can prove C1 and C2 but not C3.
Note that we can prove C2 only since the modification of $S_4$ in $\dtrans{}$.

In the definition of $add$, if we replace $Succ (add z y)$ by $Succ (add y z)$, we can't prove anything which isn't very surprising because we're to do the recursion on the first variable, not on the second one. All the more so that they don't have the same contract.

\end{document}

